From 65f8a603c920f5157f03c56e0d367c1bd867def1 Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Wed, 22 Aug 2018 18:36:40 +0000
Subject: [PATCH 2/2] drm: rockchip/dw_hdmi-rockchip: clock improvements from
 ChromeOS 3.14

This contains traces of 49 patches from the ChromeOS tree,
which in retrospect would be quite high on the noise vs changes,
so squashed:

CHROMIUM: drm/bridge: add pixel clock for 640x480 resolution
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: expand TMDS support list
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: expand the informal mpll config
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: correct the clock table order
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: refactor the mode table
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: redo rockchip hdmi to allow slop
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: add slop to more tables
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: added 74400000
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Adjust rockchip_mpll_cfg for 146.25
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add comments about inexact clocks
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Avoid questionable PLL settings
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: use 88.8 MHz, not 88.75 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add clks: 25.2, 68.25, 72, 79.5
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Remove high jitter modes
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Fix the 57.284 mode
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Fixup the clock to be what we expect
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Protect against > 2GHz pixel clocks
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Make safer 73.25 and 78.75
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Better 85.5 and 88.75
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Use the proper clock for slop
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Remove 66MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Use auto-generated tables
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Improve jitter
CHROMIUM: drm/rockchip: hdmi: adjust cklvl & txlvl for RF/EMI
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add rates >= 101 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 119.0 and 136.75
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 32 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 154 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 162 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Better 119 and 136.75
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 146.25 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 33.75 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 121.714 MHz for 121.75 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 97.714 MHz for 97.75 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Set cur_ctr to 0 always
CHROMIUM: drm: rockchip/hdmi: No more 297 MHz
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Add 85.5 MHz
CHROMIUM: drm: rockchip/dw_hdmi: Add a more proper 78.75
CHROMIUM: drm: rockchip/dw_hdmi: Add 78.8
CHROMIUM: drm: rockchip/dw_hdmi: Make 88.75 approx a little better
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Decrease slop
CHROMIUM: drm: rockchip/dw_hdmi: Add 83.5, remove 83.52
CHROMIUM: drm: rockchip/dw_hdmi: Make a slightly better 25.175 MHz
CHROMIUM: drm: rockchip/dw_hdmi: Make a slightly better 74.44 MHz
CHROMIUM: drm: rockchip/dw_hdmi: Make 88.75 MHz exactly
CHROMIUM: drm: rockchip/dw_hdmi: Make 73.25 MHz exactly
CHROMIUM: drm: rockchip/dw_hdmi: Make 97.75 MHz exactly
CHROMIUM: drm: rockchip/dw_hdmi: Make 101 MHz exactly

Signed-off-by: Urja Rannikko <urjaman@gmail.com>
---
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c | 267 +++++++++++++-------
 1 file changed, 176 insertions(+), 91 deletions(-)

diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index 11309a2a..b982c76e 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -51,115 +51,160 @@ struct rockchip_hdmi {
 	struct dw_hdmi *hdmi;
 };
 
+#define CLK_SLOP(clk)		((clk) / 1000)
+#define CLK_PLUS_SLOP(clk)	((clk) + CLK_SLOP(clk))
+
 #define to_rockchip_hdmi(x)	container_of(x, struct rockchip_hdmi, x)
 
+static const int dw_hdmi_rates[] = {
+	25176471,	/* for 25.175 MHz, 0.006% off */
+	25200000,
+	27000000,
+	28320000,
+	30240000,
+	31500000,
+	32000000,
+	33750000,
+	36000000,
+	40000000,
+	49500000,
+	50000000,
+	54000000,
+	57290323,	/* for 57.284 MHz, .011 % off */
+	65000000,
+	68250000,
+	71000000,
+	72000000,
+	73250000,
+	74250000,
+	74437500,	/* for 74.44 MHz, .003% off */
+	75000000,
+	78750000,
+	78800000,
+	79500000,
+	83500000,
+	85500000,
+	88750000,
+	97750000,
+	101000000,
+	106500000,
+	108000000,
+	115500000,
+	118666667,	/* for 118.68 MHz, .011% off */
+	119000000,
+	121714286,	/* for 121.75 MHz, .029% off */
+	135000000,
+	136800000,	/* for 136.75 MHz, .037% off */
+	146250000,
+	148500000,
+	154000000,
+	162000000,
+};
+
+
 static const struct dw_hdmi_mpll_config rockchip_mpll_cfg[] = {
 	{
-		27000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+		30666000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40f3, 0x0000 },
+		},
+	},  {
+		36800000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		36000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+	},  {
+		46000000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		40000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+	},  {
+		61333000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		54000000, {
-			{ 0x0072, 0x0001},
-			{ 0x2142, 0x0001},
-			{ 0x40a2, 0x0001},
+	},  {
+		73600000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		65000000, {
-			{ 0x0072, 0x0001},
-			{ 0x2142, 0x0001},
-			{ 0x40a2, 0x0001},
+	},  {
+		92000000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		66000000, {
-			{ 0x013e, 0x0003},
-			{ 0x217e, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		122666000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		74250000, {
-			{ 0x0072, 0x0001},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		147200000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		83500000, {
-			{ 0x0072, 0x0001},
+	},  {
+		184000000, {
+			{ 0x0051, 0x0002 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		108000000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		226666000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		106500000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		272000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x5a64, 0x0003 },
 		},
-	}, {
-		146250000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		340000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
 		},
-	}, {
-		148500000, {
-			{ 0x0051, 0x0003},
-			{ 0x214c, 0x0003},
-			{ 0x4064, 0x0003}
+	},  {
+		600000000, {
+			{ 0x1a40, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
 		},
-	}, {
+	},  {
 		~0UL, {
-			{ 0x00a0, 0x000a },
-			{ 0x2001, 0x000f },
-			{ 0x4002, 0x000f },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
 		},
 	}
 };
 
 static const struct dw_hdmi_curr_ctrl rockchip_cur_ctr[] = {
-	/*      pixelclk    bpp8    bpp10   bpp12 */
+	/*      pixelclk     bpp8    bpp10   bpp12 */
 	{
-		40000000,  { 0x0018, 0x0018, 0x0018 },
-	}, {
-		65000000,  { 0x0028, 0x0028, 0x0028 },
-	}, {
-		66000000,  { 0x0038, 0x0038, 0x0038 },
-	}, {
-		74250000,  { 0x0028, 0x0038, 0x0038 },
-	}, {
-		83500000,  { 0x0028, 0x0038, 0x0038 },
-	}, {
-		146250000, { 0x0038, 0x0038, 0x0038 },
-	}, {
-		148500000, { 0x0000, 0x0038, 0x0038 },
-	}, {
-		~0UL,      { 0x0000, 0x0000, 0x0000},
-	}
+		600000000, { 0x0000, 0x0000, 0x0000 },
+	},  {
+		~0UL,      { 0x0000, 0x0000, 0x0000 },
+	},
 };
 
 static const struct dw_hdmi_phy_config rockchip_phy_config[] = {
 	/*pixelclk   symbol   term   vlev*/
-	{ 74250000,  0x8009, 0x0004, 0x0272},
-	{ 148500000, 0x802b, 0x0004, 0x028d},
-	{ 297000000, 0x8039, 0x0005, 0x028d},
-	{ ~0UL,	     0x0000, 0x0000, 0x0000}
+	{ CLK_PLUS_SLOP(74250000),  0x8009, 0x0004, 0x0272},
+	{ CLK_PLUS_SLOP(165000000), 0x802b, 0x0004, 0x0209},
+	{ CLK_PLUS_SLOP(297000000), 0x8039, 0x0005, 0x028d},
+	{ ~0UL,	                    0x0000, 0x0000, 0x0000}
 };
 
 static int rockchip_hdmi_parse_dt(struct rockchip_hdmi *hdmi)
@@ -199,19 +244,27 @@ static enum drm_mode_status
 dw_hdmi_rockchip_mode_valid(struct drm_connector *connector,
 			    const struct drm_display_mode *mode)
 {
-	const struct dw_hdmi_mpll_config *mpll_cfg = rockchip_mpll_cfg;
 	int pclk = mode->clock * 1000;
-	bool valid = false;
+	int num_rates = ARRAY_SIZE(dw_hdmi_rates);
 	int i;
 
-	for (i = 0; mpll_cfg[i].mpixelclock != (~0UL); i++) {
-		if (pclk == mpll_cfg[i].mpixelclock) {
-			valid = true;
-			break;
-		}
+	/*
+	 * Pixel clocks we support are always < 2GHz and so fit in an
+	 * int.  We should make sure source rate does too so we don't get
+	 * overflow when we multiply by 1000.
+	 */
+	if (mode->clock > INT_MAX / 1000)
+		return MODE_BAD;
+
+	for (i = 0; i < num_rates; i++) {
+		int slop = CLK_SLOP(pclk);
+
+		if ((pclk >= dw_hdmi_rates[i] - slop) &&
+		    (pclk <= dw_hdmi_rates[i] + slop))
+			return MODE_OK;
 	}
 
-	return (valid) ? MODE_OK : MODE_BAD;
+	return MODE_BAD;
 }
 
 static const struct drm_encoder_funcs dw_hdmi_rockchip_encoder_funcs = {
@@ -227,7 +280,39 @@ dw_hdmi_rockchip_encoder_mode_fixup(struct drm_encoder *encoder,
 				    const struct drm_display_mode *mode,
 				    struct drm_display_mode *adj_mode)
 {
-	return true;
+	struct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);
+	int pclk = adj_mode->clock * 1000;
+	int best_diff = INT_MAX;
+	int best_clock = 0;
+	int slop;
+	int i;
+
+	/* Pick the best clock */
+	for (i = 0; i < ARRAY_SIZE(dw_hdmi_rates); i++) {
+		int diff = dw_hdmi_rates[i] - pclk;
+
+		if (diff < 0)
+			diff = -diff;
+		if (diff < best_diff) {
+			best_diff = diff;
+			best_clock = dw_hdmi_rates[i];
+
+			/* Bail early if we're exact */
+			if (best_diff == 0)
+				return true;
+		}
+	}
+
+	/* Double check that it's OK */
+	slop = CLK_SLOP(pclk);
+	if ((pclk >= best_clock - slop) && (pclk <= best_clock + slop)) {
+		adj_mode->clock = DIV_ROUND_UP(best_clock, 1000);
+		return true;
+	}
+
+	/* Shoudn't be here; we should have said rate wasn't valid */
+	dev_warn(hdmi->dev, "tried to set invalid rate %d\n", adj_mode->clock);
+	return false;
 }
 
 static void dw_hdmi_rockchip_encoder_mode_set(struct drm_encoder *encoder,
-- 
2.18.0

